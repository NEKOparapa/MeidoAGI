{"version":3,"file":"Extract.js","sources":["../src/Extract.ts"],"sourcesContent":["import { extensions, ExtensionType, Rectangle, RenderTexture, utils } from '@pixi/core';\n\nimport type { ExtensionMetadata, ICanvas, ISystem, Renderer } from '@pixi/core';\nimport type { DisplayObject } from '@pixi/display';\n\nconst TEMP_RECT = new Rectangle();\nconst BYTES_PER_PIXEL = 4;\n\nexport interface IExtract\n{\n    image(target?: DisplayObject | RenderTexture, format?: string, quality?: number): Promise<HTMLImageElement>;\n    base64(target?: DisplayObject | RenderTexture, format?: string, quality?: number): Promise<string>;\n    canvas(target?: DisplayObject | RenderTexture, frame?: Rectangle): ICanvas;\n    pixels(target?: DisplayObject | RenderTexture, frame?: Rectangle): Uint8Array | Uint8ClampedArray;\n}\n\n/**\n * This class provides renderer-specific plugins for exporting content from a renderer.\n * For instance, these plugins can be used for saving an Image, Canvas element or for exporting the raw image data (pixels).\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.extract` property.\n * @example\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application (extract will be auto-added to renderer)\n * const app = new Application();\n *\n * // Draw a red circle\n * const graphics = new Graphics()\n *     .beginFill(0xFF0000)\n *     .drawCircle(0, 0, 50);\n *\n * // Render the graphics as an HTMLImageElement\n * const image = await app.renderer.extract.image(graphics);\n * document.body.appendChild(image);\n * @memberof PIXI\n */\n\nexport class Extract implements ISystem, IExtract\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'extract',\n        type: ExtensionType.RendererSystem,\n    };\n\n    private renderer: Renderer | null;\n\n    /**\n     * @param renderer - A reference to the current renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Will return a HTML Image of the target\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param format - Image format, e.g. \"image/jpeg\" or \"image/webp\".\n     * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.\n     * @returns - HTML Image of the target\n     */\n    public async image(target?: DisplayObject | RenderTexture, format?: string, quality?: number): Promise<HTMLImageElement>\n    {\n        const image = new Image();\n\n        image.src = await this.base64(target, format, quality);\n\n        return image;\n    }\n\n    /**\n     * Will return a base64 encoded string of this target. It works by calling\n     *  `Extract.getCanvas` and then running toDataURL on that.\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param format - Image format, e.g. \"image/jpeg\" or \"image/webp\".\n     * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.\n     * @returns - A base64 encoded string of the texture.\n     */\n    public async base64(target?: DisplayObject | RenderTexture, format?: string, quality?: number): Promise<string>\n    {\n        const canvas = this.canvas(target);\n\n        if (canvas.toBlob !== undefined)\n        {\n            return new Promise<string>((resolve, reject) =>\n            {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                canvas.toBlob!((blob) =>\n                {\n                    if (!blob)\n                    {\n                        reject(new Error('ICanvas.toBlob failed!'));\n\n                        return;\n                    }\n\n                    const reader = new FileReader();\n\n                    reader.onload = () => resolve(reader.result as string);\n                    reader.onerror = reject;\n                    reader.readAsDataURL(blob);\n                }, format, quality);\n            });\n        }\n        if (canvas.toDataURL !== undefined)\n        {\n            return canvas.toDataURL(format, quality);\n        }\n        if (canvas.convertToBlob !== undefined)\n        {\n            const blob = await canvas.convertToBlob({ type: format, quality });\n\n            return new Promise<string>((resolve, reject) =>\n            {\n                const reader = new FileReader();\n\n                reader.onload = () => resolve(reader.result as string);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n        }\n\n        throw new Error('Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, '\n            + 'or ICanvas.convertToBlob to be implemented');\n    }\n\n    /**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param frame - The frame the extraction is restricted to.\n     * @returns - A Canvas element with the texture rendered on.\n     */\n    public canvas(target?: DisplayObject | RenderTexture, frame?: Rectangle): ICanvas\n    {\n        const { pixels, width, height, flipY } = this._rawPixels(target, frame);\n\n        // Flipping pixels\n        if (flipY)\n        {\n            Extract._flipY(pixels, width, height);\n        }\n\n        Extract._unpremultiplyAlpha(pixels);\n\n        const canvasBuffer = new utils.CanvasRenderTarget(width, height, 1);\n\n        // Add the pixels to the canvas\n        const imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);\n\n        canvasBuffer.context.putImageData(imageData, 0, 0);\n\n        // Send the canvas back\n        return canvasBuffer.canvas;\n    }\n\n    /**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param frame - The frame the extraction is restricted to.\n     * @returns - One-dimensional array containing the pixel data of the entire texture\n     */\n    public pixels(target?: DisplayObject | RenderTexture, frame?: Rectangle): Uint8Array\n    {\n        const { pixels, width, height, flipY } = this._rawPixels(target, frame);\n\n        if (flipY)\n        {\n            Extract._flipY(pixels, width, height);\n        }\n\n        Extract._unpremultiplyAlpha(pixels);\n\n        return pixels;\n    }\n\n    private _rawPixels(target?: DisplayObject | RenderTexture, frame?: Rectangle): {\n        pixels: Uint8Array, width: number, height: number, flipY: boolean,\n    }\n    {\n        const renderer = this.renderer;\n\n        if (!renderer)\n        {\n            throw new Error('The Extract has already been destroyed');\n        }\n\n        let resolution;\n        let flipY = false;\n        let renderTexture;\n        let generated = false;\n\n        if (target)\n        {\n            if (target instanceof RenderTexture)\n            {\n                renderTexture = target;\n            }\n            else\n            {\n                renderTexture = renderer.generateTexture(target, {\n                    resolution: renderer.resolution,\n                    multisample: renderer.multisample\n                });\n                generated = true;\n            }\n        }\n\n        if (renderTexture)\n        {\n            resolution = renderTexture.baseTexture.resolution;\n            frame = frame ?? renderTexture.frame;\n            flipY = false;\n\n            if (!generated)\n            {\n                renderer.renderTexture.bind(renderTexture);\n\n                const fbo = renderTexture.framebuffer.glFramebuffers[renderer.CONTEXT_UID];\n\n                if (fbo.blitFramebuffer)\n                {\n                    renderer.framebuffer.bind(fbo.blitFramebuffer);\n                }\n            }\n        }\n        else\n        {\n            resolution = renderer.resolution;\n\n            if (!frame)\n            {\n                frame = TEMP_RECT;\n                frame.width = renderer.width / resolution;\n                frame.height = renderer.height / resolution;\n            }\n\n            flipY = true;\n            renderer.renderTexture.bind();\n        }\n\n        const width = Math.round(frame.width * resolution);\n        const height = Math.round(frame.height * resolution);\n\n        const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n        // Read pixels to the array\n        const gl = renderer.gl;\n\n        gl.readPixels(\n            Math.round(frame.x * resolution),\n            Math.round(frame.y * resolution),\n            width,\n            height,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            pixels\n        );\n\n        if (generated)\n        {\n            renderTexture?.destroy(true);\n        }\n\n        return { pixels, width, height, flipY };\n    }\n\n    /** Destroys the extract. */\n    public destroy(): void\n    {\n        this.renderer = null;\n    }\n\n    private static _flipY(pixels: Uint8Array | Uint8ClampedArray, width: number, height: number): void\n    {\n        const w = width << 2;\n        const h = height >> 1;\n        const temp = new Uint8Array(w);\n\n        for (let y = 0; y < h; y++)\n        {\n            const t = y * w;\n            const b = (height - y - 1) * w;\n\n            temp.set(pixels.subarray(t, t + w));\n            pixels.copyWithin(t, b, b + w);\n            pixels.set(temp, b);\n        }\n    }\n\n    private static _unpremultiplyAlpha(pixels: Uint8Array | Uint8ClampedArray): void\n    {\n        if (pixels instanceof Uint8ClampedArray)\n        {\n            pixels = new Uint8Array(pixels.buffer);\n        }\n\n        const n = pixels.length;\n\n        for (let i = 0; i < n; i += 4)\n        {\n            const alpha = pixels[i + 3];\n\n            if (alpha !== 0)\n            {\n                const a = 255.001 / alpha;\n\n                pixels[i] = (pixels[i] * a) + 0.5;\n                pixels[i + 1] = (pixels[i + 1] * a) + 0.5;\n                pixels[i + 2] = (pixels[i + 2] * a) + 0.5;\n            }\n        }\n    }\n}\n\nextensions.add(Extract);\n"],"names":["Rectangle","utils","RenderTexture","ExtensionType","extensions"],"mappings":"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"}