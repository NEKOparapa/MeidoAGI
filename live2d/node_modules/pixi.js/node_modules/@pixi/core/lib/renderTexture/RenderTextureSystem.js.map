{"version":3,"file":"RenderTextureSystem.js","sources":["../../src/renderTexture/RenderTextureSystem.ts"],"sourcesContent":["import { Color } from '@pixi/color';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { Rectangle } from '@pixi/math';\n\nimport type { ColorSource } from '@pixi/color';\nimport type { BUFFER_BITS } from '@pixi/constants';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { ISize } from '@pixi/math';\nimport type { MaskData } from '../mask/MaskData';\nimport type { Renderer } from '../Renderer';\nimport type { ISystem } from '../system/ISystem';\nimport type { BaseRenderTexture } from './BaseRenderTexture';\nimport type { RenderTexture } from './RenderTexture';\n\n// Temporary rectangle for assigned sourceFrame or destinationFrame\nconst tempRect = new Rectangle();\n\n// Temporary rectangle for renderTexture destinationFrame\nconst tempRect2 = new Rectangle();\n\n/* eslint-disable max-len */\n/**\n * System plugin to the renderer to manage render textures.\n *\n * Should be added after FramebufferSystem\n *\n * ### Frames\n *\n * The `RenderTextureSystem` holds a sourceFrame â†’ destinationFrame projection. The following table explains the different\n * coordinate spaces used:\n *\n * | Frame                  | Description                                                      | Coordinate System                                       |\n * | ---------------------- | ---------------------------------------------------------------- | ------------------------------------------------------- |\n * | sourceFrame            | The rectangle inside of which display-objects are being rendered | **World Space**: The origin on the top-left             |\n * | destinationFrame       | The rectangle in the render-target (canvas or texture) into which contents should be rendered | If rendering to the canvas, this is in screen space and the origin is on the top-left. If rendering to a render-texture, this is in its base-texture's space with the origin on the bottom-left.  |\n * | viewportFrame          | The framebuffer viewport corresponding to the destination-frame  | **Window Coordinates**: The origin is always on the bottom-left. |\n * @memberof PIXI\n */\nexport class RenderTextureSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'renderTexture',\n    };\n\n    /* eslint-enable max-len */\n\n    /**\n     * List of masks for the {@link PIXI.StencilSystem}.\n     * @readonly\n     */\n    public defaultMaskStack: Array<MaskData>;\n\n    /**\n     * Render texture currently bound. {@code null} if rendering to the canvas.\n     * @readonly\n     */\n    public current: RenderTexture | null;\n\n    /**\n     * The source frame for the render-target's projection mapping.\n     *\n     * See {@link PIXI.ProjectionSystem#sourceFrame} for more details\n     */\n    public readonly sourceFrame: Rectangle;\n\n    /**\n     * The destination frame for the render-target's projection mapping.\n     *\n     * See {@link PIXI.ProjectionSystem#destinationFrame} for more details.\n     */\n    public readonly destinationFrame: Rectangle;\n\n    /**\n     * The viewport frame for the render-target's viewport binding. This is equal to the destination-frame\n     * for render-textures, while it is y-flipped when rendering to the screen (i.e. its origin is always on\n     * the bottom-left).\n     */\n    public readonly viewportFrame: Rectangle;\n\n    private renderer: Renderer;\n\n    /** Does the renderer have alpha and are its color channels stored premultipled by the alpha channel? */\n    private _rendererPremultipliedAlpha: boolean;\n\n    /**\n     * @param renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n\n        this.defaultMaskStack = [];\n        this.current = null;\n        this.sourceFrame = new Rectangle();\n        this.destinationFrame = new Rectangle();\n        this.viewportFrame = new Rectangle();\n    }\n\n    protected contextChange(): void\n    {\n        const attributes = this.renderer?.gl.getContextAttributes();\n\n        this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);\n    }\n\n    /**\n     * Bind the current render texture.\n     * @param renderTexture - RenderTexture to bind, by default its `null` - the screen.\n     * @param sourceFrame - Part of world that is mapped to the renderTexture.\n     * @param destinationFrame - Part of renderTexture, by default it has the same size as sourceFrame.\n     */\n    bind(renderTexture: RenderTexture = null, sourceFrame?: Rectangle, destinationFrame?: Rectangle): void\n    {\n        const renderer = this.renderer;\n\n        this.current = renderTexture;\n\n        let baseTexture: BaseRenderTexture;\n        let framebuffer;\n        let resolution;\n\n        if (renderTexture)\n        {\n            baseTexture = renderTexture.baseTexture as BaseRenderTexture;\n\n            resolution = baseTexture.resolution;\n\n            if (!sourceFrame)\n            {\n                tempRect.width = renderTexture.frame.width;\n                tempRect.height = renderTexture.frame.height;\n\n                sourceFrame = tempRect;\n            }\n\n            if (!destinationFrame)\n            {\n                tempRect2.x = renderTexture.frame.x;\n                tempRect2.y = renderTexture.frame.y;\n                tempRect2.width = sourceFrame.width;\n                tempRect2.height = sourceFrame.height;\n\n                destinationFrame = tempRect2;\n            }\n\n            framebuffer = baseTexture.framebuffer;\n        }\n        else\n        {\n            resolution = renderer.resolution;\n\n            if (!sourceFrame)\n            {\n                tempRect.width = renderer._view.screen.width;\n                tempRect.height = renderer._view.screen.height;\n\n                sourceFrame = tempRect;\n            }\n\n            if (!destinationFrame)\n            {\n                destinationFrame = tempRect;\n\n                destinationFrame.width = sourceFrame.width;\n                destinationFrame.height = sourceFrame.height;\n            }\n        }\n\n        const viewportFrame = this.viewportFrame;\n\n        viewportFrame.x = destinationFrame.x * resolution;\n        viewportFrame.y = destinationFrame.y * resolution;\n        viewportFrame.width = destinationFrame.width * resolution;\n        viewportFrame.height = destinationFrame.height * resolution;\n\n        if (!renderTexture)\n        {\n            viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);\n        }\n\n        viewportFrame.ceil();\n\n        this.renderer.framebuffer.bind(framebuffer, viewportFrame);\n        this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);\n\n        if (renderTexture)\n        {\n            this.renderer.mask.setMaskStack(baseTexture.maskStack);\n        }\n        else\n        {\n            this.renderer.mask.setMaskStack(this.defaultMaskStack);\n        }\n\n        this.sourceFrame.copyFrom(sourceFrame);\n        this.destinationFrame.copyFrom(destinationFrame);\n    }\n\n    /**\n     * Erases the render texture and fills the drawing area with a colour.\n     * @param clearColor - The color as rgba, default to use the renderer backgroundColor\n     * @param [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks\n     *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.\n     */\n    clear(clearColor?: ColorSource, mask?: BUFFER_BITS): void\n    {\n        const fallbackColor = this.current\n            ? this.current.baseTexture.clear\n            : this.renderer.background.backgroundColor;\n        const color = Color.shared.setValue(clearColor ? clearColor : fallbackColor);\n\n        if ((this.current && this.current.baseTexture.alphaMode > 0)\n            || (!this.current && this._rendererPremultipliedAlpha))\n        {\n            color.premultiply(color.alpha);\n        }\n\n        const destinationFrame = this.destinationFrame;\n        const baseFrame: ISize = this.current ? this.current.baseTexture : this.renderer._view.screen;\n        const clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;\n\n        if (clearMask)\n        {\n            let { x, y, width, height } = this.viewportFrame;\n\n            x = Math.round(x);\n            y = Math.round(y);\n            width = Math.round(width);\n            height = Math.round(height);\n\n            // TODO: ScissorSystem should cache whether the scissor test is enabled or not.\n            this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);\n            this.renderer.gl.scissor(x, y, width, height);\n        }\n\n        this.renderer.framebuffer.clear(color.red, color.green, color.blue, color.alpha, mask);\n\n        if (clearMask)\n        {\n            // Restore the scissor box\n            this.renderer.scissor.pop();\n        }\n    }\n\n    resize(): void // screenWidth, screenHeight)\n    {\n        // resize the root only!\n        this.bind(null);\n    }\n\n    /** Resets render-texture state. */\n    reset(): void\n    {\n        this.bind(null);\n    }\n\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n\nextensions.add(RenderTextureSystem);\n"],"names":["Rectangle","color","Color","ExtensionType","extensions"],"mappings":"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"}